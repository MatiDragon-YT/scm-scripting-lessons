Трюк с локальными массивами|В этом уроке Вы узнаете об одном трюке, который существенно сократит время написания однотипного кода.|wmysterio|wmysterio||||Всем привет! С Вами**wmysterio**. В этом уроке Вы узнаете об одном интересном методе, который упростит написание кода с локальными массивами.

Как известно, каждый поток имеет свой набор локальных переменных, доступ к которым осуществляется с помощью символа **@**. Массивы же являются группой переменных из этого диапазона. Многие забывают, что мы можем использовать отдельно переменную из этого массива и обращаться как к обычной переменной. Этот трюк заключается как раз в этом - мы можем брать отдельную переменную из массива или формировать массивы из отдельных переменных, что идут последовательно.

Рассмотрим следующий код:


```

{$CLEO} 
0@ = 0 
0376: 10@(0@,5i) = create_random_actor_at 2505.6489 -1664.1635 13.397 
0@ += 1 
0376: 10@(0@,5i) = create_random_actor_at 2506.1484 -1668.5974 13.3742 
0@ += 1 
0376: 10@(0@,5i) = create_random_actor_at 2504.1794 -1673.494 13.3634 
0@ += 1 
0376: 10@(0@,5i) = create_random_actor_at 2499.0459 -1675.1171 13.3458 
0@ += 1 
0376: 10@(0@,5i) = create_random_actor_at 2495.4204 -1660.1552 13.3359 

for 0@ = 0 to 4 
0187: 20@(0@,5i) = create_marker_above_actor 10@(0@,5i) 
end 

0A93: end_custom_thread
```



А теперь представьте, что нужно изменить тип маркера только одного элемента из массива. Что же нам теперь при необходимости менять значение 0@, чтобы добиться доступа к конкретной переменной?


```

0@ = 3
07E0: set_marker 20@(0@,5i) type_to 1
```



А что будет, если нам нужна будет эта переменная везде, при этом у нас есть ещё некая работа с элементами массива по-отдельности? Естественно, такой метод нас не устроит! Значит, нам нужно использовать тот трюк, что написан выше. Для начала нужно разобраться какой диапазон актёров и маркеров содержит массив. В нашем случаи - это 5 актёров и 5 маркеров. Соответственно, диапазон актёров составляет последовательность из переменных: 10@ 11@ 12@ 13@ 14@, а диапазон маркеров - 20@ 21@ 22@ 23@ 24@

Формат массива всегда указывает количество переменных, их тип а также начальную переменную массива. Всё, что нам оставалось - это посчитать диапазон: 10 + 5 = 15. Поскольку итерация начинается с 0 а не с 1 в Sanny Builder, то число 15 уже не входит в диапазон, а последним элементом является 14. Немного математики и, по-аналогии, я так рассчитал диапазон для маркеров.

Теперь вернёмся к нашему примеру и попробуем изменить тип 3-го элемента массива. Начиная отсчёт с нуля, мы получили переменную 22@.


```

07E0: set_marker 22@ type_to 1
```



Как видите, мы сократили скрипт на 1 опкод. В крупных проектах этих команд наберётся целая куча, которая будет занимать существенное место по объёму и скрипт будет выполнять намного больше команд, чем требуется. Аналогичным образом, давайте сократим скрипт с созданием актёров:


```

{$CLEO}

0376: 10@ = create_random_actor_at 2505.6489 -1664.1635 13.397 
0376: 11@ = create_random_actor_at 2506.1484 -1668.5974 13.3742 
0376: 12@ = create_random_actor_at 2504.1794 -1673.494 13.3634 
0376: 13@ = create_random_actor_at 2499.0459 -1675.1171 13.3458
0376: 14@ = create_random_actor_at 2495.4204 -1660.1552 13.3359

for 0@ = 0 to 4
0187: 20@(0@,5i) = create_marker_above_actor 10@(0@,5i)
end

07E0: set_marker 22@ type_to 1
0A93: end_custom_thread
```



<!--IMG1--><img src="https://github.com/wmysterio/scm-scripting-lessons/raw/resources/_pu/2/68703011.png" /><!--IMG1--><br>

Такой код намного легче читать, если знать этот трюк! Изначально скрипт имел размер 219 байт. После нашего исправления - 153 байта. Фактически, мы сэкономили 66 байт на наш скрипт. Оптимизация по размеру и быстродействию составляет 69%!!! И это только в небольшом скрипте. В крупных проектах эта цифра будет ещё больше.

Согласитесь, такой подход существенно улучшает производительность нашего кода а также упрощает его читаемость. Если немного потренироваться, то метод освоить не составит труда. Спасибо всем за внимание!|1421|1|0|68703011`png`480`360`320`240``\||trjuk_s_lokalnymi_massivami|1509826424