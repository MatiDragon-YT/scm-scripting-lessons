Цикл foreach для своих классов||wmysterio|wmysterio|wmysterio@yandex.ru|/||<div>Всем привет! С вами, как обычно, wmysterio, и мы продолжаем изучать c#. В этом уроке мы постарается изучить одну интересную и не менее важную концепцию в c#. Как помочь классам подружиться с циклом foreach. Это обычно необходимо, когда класс имеет скрытое поле с массивом. При обращении к циклу, класс должен перебирать внутренний массив без необходимости получения его из вне.</div><div>Чтобы узнать, что я имею ввиду, создадим несколько классов для примера. Первый класс будет иметь следующий вид:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->public class ClassB {<br>&nbsp;&nbsp; int _value;<br>&nbsp;&nbsp; public ClassB( int value ) { _value = value; }<br>&nbsp;&nbsp; public override string ToString() { return _value.ToString(); }<br>}<!--/uzc--></div></div><!--/uzcode-->Класс ничего не делает, но он будет являться важным содержимым для следующего класса:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->public class ClassA : IEnumerable {<br>&nbsp;&nbsp; ClassB[] bList;<br>&nbsp;&nbsp; public ClassA() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bList = new ClassB[3] {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ClassB(10), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ClassB(-5), <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new ClassB(0) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };<br>&nbsp; }<br>&nbsp;&nbsp; public IEnumerator GetEnumerator() { <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for ( int i = 0; i &lt; bList.Length; i++ )<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield return bList[ i ];<br>&nbsp;&nbsp; }<br>}<!--/uzc--></div></div><!--/uzcode-->Сразу в глаза попадаются два момента: реализация метода&nbsp;GetEnumerator()&nbsp;&nbsp;из интерфейса IEnumerable и использование нового для Вас оператора yield. Об интерфейсах я расскажу Вам немного позже.</div><div>&nbsp;</div><div>Оператор yield используется для возвращения по очереди каждого элемента. То есть - отдавать кусками. Не ждать прохождения всего цикла, а отдавать элемент цикла в foreach, так только итерация цикла foreach завершилась, идёт получение следующего куска из цикла for, где находится наш yield.</div><div>&nbsp;</div><div>Чтобы понять как это работает, давайте в приложении создадим класс ClassA и пройдёмся в цикле foreach и увидим результат:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->class Program {<br>&nbsp;&nbsp; static void Main( string[] args ) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ClassA ca = new ClassA();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach ( ClassB item in ca ) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.WriteLine( item );<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Console.ReadKey();<br>&nbsp;&nbsp; }<br>}<!--/uzc--></div></div><!--/uzcode-->Если Мы не знали что находится в классе ClassA, то нам и в голову не пришло бы, что с ним вообще возможный перебор через foreach. Обычно данный приём используется не для скрытия такой возможности, а для реализации этого класса в цикле foreach, и не только в нём.<br></div>|912|1|0|42460690`png`108`113\||cikl_foreach_dlja_svoikh_klassov|1423936483