[SA&#124;C++]Plugin SDK. Простейший плагин.|<i>**Написание простого ASI плагина с plugin-sdk.**</i>|DK22Pac|DK22Pac||||Для написания плагина с plugin-sdk необходимо следующее:


- Установить Visual Studio (желательно последнюю версию - 2017). Подробнее - <a href="/go?https://github.com/DK22Pac/plugin-sdk/wiki/%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-%D1%81%D1%80%D0%B5%D0%B4%D1%8B-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D0%BA%D0%B8">здесь</a>;
- Скачать plugin-sdk и настроить его. Подробнее - <a href="/go?https://github.com/DK22Pac/plugin-sdk/wiki/%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-plugin-sdk">здесь</a>.


Итак, после того, как plugin-sdk настроен, мы можем создать плагин в Visual Studio. Для этого создаём новый проект и выбираем шаблон проекта Plugin-SDK в подразделе Visual C++ - Plugin-SDK:

<!--IMG1--><img src="https://github.com/wmysterio/scm-scripting-lessons/raw/resources/_pu/2/87644493.png" /><!--IMG1-->

Не забываем также указать название проекта и выбрать место его расположения. По умолчанию, у нас в проекте есть один файл исходного кода (<strong>.cpp**). Открываем этот файл и подключаем нужные заголовочные файлы.


```

cpp
#include "plugin.h"
#include "CMessages.h"
#include "CClock.h"

using namespace plugin;
```



Мы будем изменять игровое время (класс**CClock** отвечает за работу с игровыми "часами") и выводить сообщение (класс**CMessage** предоставляет функции для вывода сообщений).

Для удобства, мы разместим все данные и функции в классе. В конструктор этого класса мы поместим код инициализации нашего плагина. В глобальной области видимости мы создадим экземпляр этого класса, таким образом, при подключении нашего плагина ( а плагин - это динамическая библиотека с расширением .asi ) ASI-loader'ом, будет вызван конструктор нашего класса.

Такой подход позволяет избавиться от явного использования функции DllMain, но, впрочем, никто вам не запрещает выполнять инициализацию плагина так, как вам удобно.


```

cpp
#include "plugin.h"
#include "CMessages.h"
#include "CClock.h"

using namespace plugin;

class TestPlugin {
public:
&nbsp;&nbsp;&nbsp;&nbsp;TestPlugin() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// код инициализации плагина
&nbsp;&nbsp;&nbsp;&nbsp;}
} test; // создание экземпляра класса TestPlugin в глобальной области видимости
```



**Инициализация плагина**

В plugin-sdk реализована идея "событий" (events). Т.е., есть возможность выполнить свой код в какой-то определённый момент игры. Обращаться ко всем событиям можно из пространства имён**plugin::Events**. Вот как это выглядит:


```

cpp
Events::gameProcessEvent.Add(MyFunction); // Добавить вызов функции MyFunction, когда игра вызывает функцию CGame::Process
```



Метод**Add** добавляет указанную функцию к конкретному игровому"событию". При этом, у метода**Add** есть альтернатива в виде оператора**+=**


```

cpp
Events::gameProcessEvent += MyFunction; // Добавить вызов функции MyFunction, когда игра вызывает функцию CGame::Process
```



Также, есть возможность указать - когда именно вызывать нашу функцию - до "события" или после:


```

cpp
Events::gameProcessEvent.before += MyFunction; // Добавить вызов функции MyFunction, перед вызовом CGame::Process
Events::gameProcessEvent.after += MyFunction; // Добавить вызов функции MyFunction, поле вызова CGame::Process (стандартное поведение - т.е. аналогично вызову "Events::gameProcessEvent +=")
```



Бывают ситуации, когда такая возможность может быть действительно полезной - например, когда надо выполнить какие-то операции до и после отрисовки игрового субьекта (например, транспорта).

Ниже приведен список некоторых событий, доступных в plugin-sdk:

<table class="table table-striped">
 <thead>
 <tr>
 <th scope="col">Событие</th>
 <th scope="col">Функция-прототип</th>
 <th scope="col">Описание</th>
 </tr>
 </thead>
 <tbody>
 <tr>
 <td>drawingEvent</td>
 <td>void()</td>
 <td>Отрисовка в 2D</td>
 </tr>
 <tr>
 <td>drawHudEvent</td>
 <td>void()</td>
 <td>Отрисовка HUD-элементов</td>
 </tr>
 <tr>
 <td>drawRadarEvent</td>
 <td>void()</td>
 <td>Отрисовка радара</td>
 </tr>
 <tr>
 <td>drawBlipsEvent</td>
 <td>void()</td>
 <td>Отрисовка иконок на радаре</td>
 </tr>
 <tr>
 <td>drawRadarOverlayEvent</td>
 <td>void(bool bInMenu)</td>
 <td>Отрисовка зон влияния на радаре</td>
 </tr>
 <tr>
 <td>drawMenuBackgroundEvent</td>
 <td>void(void *menuManager)</td>
 <td>Отрисовка фона в меню</td>
 </tr>
 <tr>
 <td>initRwEvent</td>
 <td>void()</td>
 <td>Инициализация графического движка</td>
 </tr>
 <tr>
 <td>shutdownRwEvent</td>
 <td>void()</td>
 <td>Деинициализация графического движка</td>
 </tr>
 <tr>
 <td>vehicleRenderEvent</td>
 <td>void(CVehicle* vehicle)</td>
 <td>Рендер транспорта</td>
 </tr>
 <tr>
 <td>pedRenderEvent</td>
 <td>void(CPed* ped)</td>
 <td>Рендер педа</td>
 </tr>
 <tr>
 <td>objectRenderEvent</td>
 <td>void(CObject* object)</td>
 <td>Рендер обьекта</td>
 </tr>
 <tr>
 <td>vehicleSetModelEvent</td>
 <td>void(CVehicle* vehicle, int modelId)</td>
 <td>Установка модели транспорта</td>
 </tr>
 <tr>
 <td>pedSetModelEvent</td>
 <td>void(CPed* ped, int modelId)</td>
 <td>Установка модели педа</td>
 </tr>
 <tr>
 <td>d3dResetEvent</td>
 <td>void()</td>
 <td>Пересоздание D3D-девайса</td>
 </tr>
 <tr>
 <td>d3dLostEvent</td>
 <td>void()</td>
 <td>Утерян доступ к D3D-девайсу</td>
 </tr>
 <tr>
 <td>gameProcessEvent</td>
 <td>void()</td>
 <td>Обработка разных компонентов игры</td>
 </tr>
 <tr>
 <td>initGameEvent</td>
 <td>void()</td>
 <td>Инициализация игры</td>
 </tr>
 <tr>
 <td>reInitGameEvent</td>
 <td>void()</td>
 <td>Повторная инициализация игры</td>
 </tr>
 <tr>
 <td>onPauseAllSounds</td>
 <td>void()</td>
 <td>Остановка всех звуков в игре</td>
 </tr>
 <tr>
 <td>onResumeAllSounds</td>
 <td>void()</td>
 <td>Включение всех звуков в игре</td>
 </tr>
 <tr>
 <td>initScriptsEvent</td>
 <td>void()</td>
 <td>Инициализация скриптов</td>
 </tr>
 <tr>
 <td>processScriptsEvent</td>
 <td>void()</td>
 <td>Обработка скриптов</td>
 </tr>
 </tbody>
</table>

Используя лямбда-выражение в C++, мы можем записать добавление функции в таком виде:


```

cpp
Events::gameProcessEvent += [] {
&nbsp;&nbsp;&nbsp;&nbsp;// код нашей функции
};
```



**Код**.

Мы сделаем изменение времени после нажатия клавиши <kbd>Delete`. Вот так будет выглядеть наш код:


```

cpp
#include "plugin.h"
#include "CMessages.h"
#include "CClock.h"

using namespace plugin;

class TestPlugin {
public:
&nbsp;&nbsp;&nbsp;&nbsp;TestPlugin() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Events::gameProcessEvent += [] {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Если нажата клавиша Delete
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (KeyPressed(VK_DELETE)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Устанавливаем время
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CClock::SetGameClock(12, 0, CClock::ms_nGameClockDayOfWeek);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Выводим сообщение
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CMessages::AddMessageJumpQ("You have set time to ~b~12:00", 3000, 0, false);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};
&nbsp;&nbsp;&nbsp;&nbsp;}
} test;
```



Код готов, переключаемся в Release-режим и компилируем проект (<kbd>F7`).

Итак, что мы получаем в случае использования Plugin SDK? Чистые хуки без явно видимых патчей и работы напрямую с адресами памяти.|5694|191|0|87644493`png`602`482`300`240``\||sa_124_c_plugin_sdk_prostejshij_plagin|1509149624