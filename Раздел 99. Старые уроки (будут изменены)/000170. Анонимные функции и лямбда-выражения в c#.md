Анонимные функции и лямбда-выражения в c#||wmysterio|wmysterio|wmysterio@yandex.ru|/||Всем привет! В этом уроке мы ещё раз поговорим о анонимности. На этот раз речь коснётся функций. Для того, чтобы статья лучше запомнилась, Вам необходимо повторить материал о <a class="link" href="/publ/uroki_skriptinga/gta_iv/delegaty_i_sobytija_v_c/35-1-0-199" rel="nofollow" target="_blank">делегатах и событиях</a>. Поскольку делегат является ссылкой на метод, то мы можем использовать его для вызова анонимного метода. Анонимный метод - это функция, которая не имеет имени. Это даёт нам возможность писать функцию на ходу, без необходимости выносить её в область видимости экземпляра класса. Для более лучшего представления, давайте создадим проект **Windows Forms**, и кинем на форму две кнопки, которые будут иметь имена **button1** и **button2**. Теперь нам нужно обработать события на нажатия кнопки, но делать мы будет на так, как мы рассматривали ранее в уроках. Будем учится писать анонимные функции! Для этого нажимаем правую кнопку мыши на визуальной форме и выбираем пункт "Перейти к коду". Далее подпишемся на событие Click для 1-й кнопки следующим образом:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->using System.Windows.Forms; <br /> using System.Drawing; <br /> using System; <br /><br /> namespace WindowsFormsApplication1 { <br /><br />&nbsp;&nbsp;public partial class Form1 : Form { <br /><br />&nbsp;&nbsp;public Form1(&#41; { <br />&nbsp;&nbsp;InitializeComponent(&#41;; <br />&nbsp;&nbsp;button1.Click += delegate( object sender, EventArgs e&#41; { MessageBox.Show( "Вы нажали на первую кнопку!" &#41;; }; <br />&nbsp;&nbsp;} <br /><br />&nbsp;&nbsp;} <br /><br /> }<!--/uzc--></div></div><!--/uzcode-->Теперь, когда мы нажмём первую кнопку, то нам будет выводится сообщение о том, какая кнопка была нажата. С первого взгляда такая конструкция выглядит довольно громоздко, но это только так кажется при разработке Формы. Расскажу что к чему. Анонимный метод не имеет имени, по-этому имя заменяет ключевое слово **delegate**. В скобках указываются параметры с типами, которыми объявлен делегат. После этого в скобках пишется тело функции. <br /><br /> Что касается лямбда-выражений, то это не так страшно, как при прочтении названия впервые. По-сути лямбда - это краткий вариант написания анонимных функций, за что разработчикам языка огромное спасибо!!! С первого вида конструкция лямбда выглядит ещё более запутанно и странно, чем обычный вид анонимных функций. Чтобы ознакомить Вас с синтаксисом, продемонстрирую вариант на другой кнопке формы:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->using System.Windows.Forms; <br /> using System.Drawing; <br /> using System; <br /><br /> namespace WindowsFormsApplication1 { <br /><br />&nbsp;&nbsp;public partial class Form1 : Form { <br /><br />&nbsp;&nbsp;public Form1(&#41; { <br />&nbsp;&nbsp;InitializeComponent(&#41;; <br />&nbsp;&nbsp;button2.Click += ( s, e &#41; => { MessageBox.Show( "Вы нажали на вторую кнопку!" &#41;; }; <br />&nbsp;&nbsp;} <br /><br />&nbsp;&nbsp;} <br /><br /> }<!--/uzc--></div></div><!--/uzcode-->О ужас, скажет пользователь, который видит конструкцию в первый раз, так как синтаксически кажется, что там одни непонятные буквы и символы <img src="http://s49.ucoz.net/sm/15/smile.gif" border="0" align="absmiddle" alt="smile" /> Но всему этому есть простое объяснение. Для начала рассмотрим синтаксис лямбды. Она состоит из двух частей(левой и правой), которые разделены символами **=>**. Левая часть в скобках перечисляет имена параметров, которые входят в лямбду. Имена могут быть произвольными, без указания их типов. Типы параметров берутся автоматически с сигнатуры делегата события, в данном случаи это **object** и **EventArgs**. Так что из важного в левой части лямбды - это указать требуемое <u>количество</u> параметров. Правая часть лямбда-выражения - это тело функции. Естественно код стал более компактным. <br /><br /> Теперь поработаем с написанием своих делегатов и попытаемся использовать их в конструкторах. Чтобы не создавать новый проект, удалим из формы наши кнопки с реализацияей обработчиков событий а потом создадим класс **Car**, который будет у нас для экпериментов. Код класса:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->namespace WindowsFormsApplication1 { <br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;public class Car { <br /><br />&nbsp;&nbsp;public string Name { get; set; } <br />&nbsp;&nbsp;public int MaxSpeed { get; set; } <br /><br />&nbsp;&nbsp;public Car(&#41; { <br />&nbsp;&nbsp;Name = "Car"; <br />&nbsp;&nbsp;MaxSpeed = 200; <br />&nbsp;&nbsp;} <br /><br />&nbsp;&nbsp;} <br /><br /> }<!--/uzc--></div></div><!--/uzcode-->Теперь давайте сделаем так, чтобы другой конструктор позволял нам выполнять пользовательскую функцию после инициализации переменных. Для этого создадим делегат с самой простой сигнатурой чуть выше тела класса:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->public delegate void UserFunc(&#41;; // прототип пользовательской функции<!--/uzc--></div></div><!--/uzcode-->Далее добавим ещё один конструктор:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->namespace WindowsFormsApplication1 { <br />&nbsp;&nbsp;&nbsp;<br />&nbsp;&nbsp;public delegate void UserFunc(&#41;; <br /><br />&nbsp;&nbsp;public class Car { <br /><br />&nbsp;&nbsp;public string Name { get; set; } <br />&nbsp;&nbsp;public int MaxSpeed { get; set; } <br /><br />&nbsp;&nbsp;public Car(&#41; {&nbsp;&nbsp;<br />&nbsp;&nbsp;Name = "Car";&nbsp;&nbsp;<br />&nbsp;&nbsp;MaxSpeed = 200;&nbsp;&nbsp;<br />&nbsp;&nbsp;} <br /><br />&nbsp;&nbsp;public Car( UserFunc callback &#41; { <br />&nbsp;&nbsp;Name = "Car"; <br />&nbsp;&nbsp;MaxSpeed = 200; <br />&nbsp;&nbsp;callback(&#41;; // вызываем переданную функцию <br />&nbsp;&nbsp;} <br /><br />&nbsp;&nbsp;} <br /><br /> }<!--/uzc--></div></div><!--/uzcode-->Как видим, в параметр конструктора мы должны передать объект типа UserFunc, который ссылается на функцию из вне класса, а затем вызываем её в конструкторе, как обычный метод. Таким образом мы реализовали имитацию колбэка. Остаётся только научится пользоваться этой возможностью! Давайте перейдём к код нашей формы и создадим три объекта класса **Car**, естественно с разными конструкторами. Во второй конструктор мы передадим анонимную функцию, которая будет изменять фон нашей формы, в третьем воспользуемся лямбда-выражением, который изменит заголовок формы:<!--uzcode--><div class="bbCodeBlock"><div class="bbCodeName" style="padding-left:5px;font-weight:bold;font-size:7pt">Код</div><div class="codeMessage" style="border:1px inset;max-height:200px;overflow:auto;height:expression(this.scrollHeight<5?this.style.height:scrollHeight>200?'200px':''+(this.scrollHeight+5)+'px');"><!--uzc-->using System.Windows.Forms; <br /> using System.Drawing; <br /> using System; <br /><br /> namespace WindowsFormsApplication1 { <br /><br />&nbsp;&nbsp;public partial class Form1 : Form { <br /><br />&nbsp;&nbsp;public Form1(&#41; { <br />&nbsp;&nbsp;InitializeComponent(&#41;; <br /><br />&nbsp;&nbsp;Car c1 = new Car(&#41;; // 1-й транспорт <br /><br />&nbsp;&nbsp;Car c2 = new Car( delegate(&#41; { <br />&nbsp;&nbsp;BackColor = Color.Teal;&nbsp;&nbsp;<br />&nbsp;&nbsp;ForeColor = Color.White;&nbsp;&nbsp;<br />&nbsp;&nbsp;} &#41;; // 2-й транспорт <br /><br />&nbsp;&nbsp;Car c3 = new Car( (&#41; => { <br />&nbsp;&nbsp;Text = "Название изменил конструктор 3-его транспорта";&nbsp;&nbsp;<br />&nbsp;&nbsp;} &#41;; // 3-й транспорт <br /><br />&nbsp;&nbsp;} <br /><br />&nbsp;&nbsp;} <br /><br /> }<!--/uzc--></div></div><!--/uzcode-->При тестировании все задачи выполнились на ура, так что имитация удалась и мы передали функцию практически в другую функцию. Такой подход как правило ограничивается только делегатом, но креативные люди всегда смогут воспользоваться этим, для того, чтобы передавать в функцию любую функцию <img src="http://s49.ucoz.net/sm/15/smile.gif" border="0" align="absmiddle" alt="smile" /> На этом всё. Надеюсь, информация была для Вас полезной.|1089|1|0||anonimnye_funkcii_i_ljambda_vyrazhenija_v_c|1426414316