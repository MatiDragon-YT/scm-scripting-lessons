# 000132. ООП в c# Часть 1

ООП в c# Часть 1||wmysterio|wmysterio|wmysterio@yandex.ru|||Всем привет! В очередной раз мы рассмотрим возможности ЯП (языка программирования, для тех, кто не знал это сокращение ![smile](http://s49.ucoz.net/sm/15/smile.gif) ) C#, и сегодня речь пойдёт о классах. Мы научимся создавать классы и изучим базовые понятия с объектно-ориентированного программирования(ООП).\
\
Давайте начнём с понятия "Класс". Класс - это пользовательский тип данных, который содержит в себе некий набор данных, функций. Конструкцию класса вы уже видели много раз из уроков по скриптхук'у:\


| <p>СПЕЦИФИКАТОР ДОСТУПА ИМЯ КЛАССА {<br>     СПЕЦИФИКАТОР ДОСТУПА КОНСТРУКТОР() {<br><br>    }<br>    ПОЛЯ, МЕТОДЫ, СВОЙСТВА, ПРОЦЕДУРЫ.<br>}<br></p> |
| ----------------------------------------------------------------------------------------------------------------------------------------------------- |

Как уже звучало в предыдущих уроках, есть 4 спецификатора доступа public, protected, private и internal. Этот спецификатор указывает видимость содержимого класса из вне(то есть за пределами класса). Я составил таблицу, и перечислил разницу между этими спецификаторами:

| <p><strong>Спецификатор</strong><br></p> |                                                  <p><strong>Описание</strong><br></p>                                                 |
| :--------------------------------------: | :-----------------------------------------------------------------------------------------------------------------------------------: |
|                  public                  |                      <p>Публичный, поле доступно всем желающим объектам, которые работают с этим классом<br></p>                      |
|                 protected                |                                    <p>Защищённый, поле доступно только классу и его потомку<br></p>                                   |
|                  private                 |                                   <p>Приватное, поле или метод доступно только самому классу<br></p>                                  |
|                 internal                 | <p>Внутренний, поле доступно только в одной области пространства имён. Не будет виден для другого <strong>namespace</strong>.<br></p> |

Пример класса вы видели из предыдущих уроков по c#. По-этому для вас объявить класс не составит проблем. Вот у меня получился примерно такой:\


| <p>public class Car {<br>    public int Speed = 0;<br>    public int Accelerate = 0;<br>    public int Handling = 0;<br><br>    public Car() {  <br>        // Пустой конструктор  <br>    }<br><br>    public void SetSpeed(int NewSpeed) {<br>        Speed = NewSpeed;<br>    }<br>}<br></p> |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

Зелёным цветом обозначены изначальные данные, которые свойственны этому классу. Их называют полями класса.\
Синим цветом обозначен конструктор класса.\
Фиолетовым цветом обозначены функции, которые может выполнять объект класса. В C# такие функции принято называть методами, так что метод - это та же функция.\
\
Количество полей, методов и конструкторов в классе может быть сколько угодно. Так же само и классов в пространстве имён может быть сколько влезет. Давайте создадим ещё один класс:

| <p>public class Lanborghini {<br>    public int DoorCount = 4;<br>    public string EngineType = "Automatic";<br><br>    public Lanborghini() {<br>        // Пустой конструктор<br>    }<br>}<br></p> |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |

Существует такое понятие, как наследование классов. В народе это известно как понятия "Предок-Потомок", "Отец-Сын", "Иерархия классов". Это понятия  говорит о том, что класс-наследник(Сын, Потомок) может наследовать свойства, процедуры класса "Предка"("Отца"). Если навести пример из жизни, то Сын Иван может наследовать некие особые приметы Отца Дмитрия, например, цвет глаз, манеру походки и тому подобное. Давайте сделаем тоже самое в программировании. Для этого нужно объявить класса-наследника. Пусть это будет Ламборгини, который наследует класс Машина. Наш код теперь будет иметь следующий вид:

| <p>    public class Car {<br>        public int Speed = 0;<br><br>        public Car() {  <br>           <br>        }<br><br>        public void SetSpeed(int NewSpeed) {<br>            Speed = NewSpeed;<br>        }<br>    }<br><br>    public class Lanborghini : Car{<br>        public int DoorCount = 4;<br>        public string EngineType = "Automatic";<br><br>        public Lanborghini() {<br>           <br>        }<br>    }<br></p> |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

Распознать класс-наследника можно по этой записи:

Это значит, что класс Lanborghini наследует некие методы и свойства класса Car и при этом имеет свои же методы. Давайте напишем код программы, где мы создадим объект класса Lanborghini:

| <p>using System;<br><br>namespace Consol {<br>    class Program {<br>        static void Main() {<br>           <br>            Lanborghini Lambo = new Lanborghini();<br><br>            // Здесь будут другие команды<br>            Console.ReadKey();<br>        }<br>    }<br><br>    public class Car {<br>        public int Speed = 0;<br><br>        public Car() {  <br>           <br>        }<br><br>        public void SetSpeed(int NewSpeed) {<br>            Speed = NewSpeed;<br>        }<br>    }<br><br>    public class Lanborghini : Car{<br>        public int DoorCount = 4;<br>        public string EngineType = "Automatic";<br><br>        public Lanborghini() {<br>           <br>        }<br>    }<br>}<br></p> |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |

Давайте посмотрим какие же свойства и команды имеет объект, что мы создали:\
![](../../\_pu/1/49862482.png)\
Оранжевым стрелками обозначены поля, которые имеет сам класс Lanborghini. Но откуда взялись поля, обозначены зелёными стрелками??? Здесь и проявилось наследование! Класс заимствовал эти поля из класса Car и теперь мы можем применять их к нашей Ламбо ![smile](http://s49.ucoz.net/sm/15/smile.gif) Теперь важную роль играет спецификаторы доступа. Давайте в классе Car мы напишем private возле процедуры SetSpeed:

И теперь посмотрим, что нам скажет объект Lambo:\
![](../../\_pu/1/26345781.png)\
Процедура пропала! Таким образом класс Lanborghini не смог наследовать её из класса Car. Теперь, я думаю, вы поняли для чего нужны эти спецификаторы вообще :)\
\
Давайте сделаем эксперимент: создадим класс Gallardo, который будет потомком класса Lamborghini, и посмотрим, что унаследует он от Предка:

| <p>public class Gallardo : Lanborghini {<br>    public int EnginePower = 1500;<br>    public int TireSize = 4;<br><br>    public Gallardo() {<br><br>    }<br>}<br></p> |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

Создадим в теле программы объект класса Gallardo и посмотрим его наследство (если вы понимаете о чём я ![tongue](http://s49.ucoz.net/sm/15/tongue.gif) )

| <p>Gallardo MyCar = new Gallardo();<br></p> |
| ------------------------------------------- |

Унаследовал вот что:\
![](../../\_pu/1/42299098.png)\
Оранжевыми стрелками показаны поля, которые имеет класс Gallardo, зелёными стрелками указаны поля, которые унаследовал класс от Lanborghini. Что же значит синяя стрелка? Он её унаследовал от класса Car. Как такое возможно, ведь мы указали, что наследовать нужно из класса Lanborghini? Здесь можно сделать вывод: "Всё, что наследует класс-Отец от своего класса-Отца наследуется и для потомка". Если взять выражение из жизни, то можно выразится так: "Всё что наследует Отец от своего Дедушки, наследуется и для Сына". В этом и суть иерархии классов. Можно сделать такую картинку, что бы легче понять:\
[![](../../\_pu/1/s80243543.jpg)](../../\_pu/1/80243543.png)\
Оранжевыми стрелками указаны поля классов, которые задаются изначально в классе.\
Зелёными стрелками показано какие поля унаследует класс от своего отца.\
Синими стрелками показано какие поля унаследуются классом от более "старших" классов\
\
Несколько слов скажу о спецификаторе protected. Если в классе Car сделать переменную Speed с этим спецификатором

| <p>protected int Speed = 0;<br></p> |
| ----------------------------------- |

то класс-потом его унаследует, но вызвать его из вне не получится\
![](../../\_pu/1/37370351.png)\
Но получать доступ к этому полю мы можем внутри. Если в конструкторе мы нажмём **CTRL**+**ПРОБЕЛ**, то мы сможем увидеть наследованное поле:\
![](../../\_pu/1/46562547.png)\
Ключик возле поля указывает, что параметр унаследовался со спецификатором protected. Мы можем создать поле в классе Gallardo, которое будет принимать унаследованное значение

| <p>public int GSpeed;<br></p> |
| ----------------------------- |

А в конструкторе заполним его:\


| <p>public Gallardo() {<br>    GSpeed = Speed;<br>}<br></p> |
| ---------------------------------------------------------- |

И теперь мы сможем увидеть поле GSpeed в теле основной программы, как поле, унаследованное от Car, которое переданное в поле класса Gallardo (как видите пошла тафтология и повторение терминов, так как я не могу подобрать нужных синонимов к этим словам ![smile](http://s49.ucoz.net/sm/15/smile.gif) ):\
![](../../\_pu/1/07018888.png)\
Если подобное сделать для класса Lanborghini:\


| <p>    public class Lanborghini : Car{<br>        public int DoorCount = 4;<br>        public string EngineType = "Automatic";<br>        public int GSpeed;<br><br>        public Lanborghini() {<br>            GSpeed = Speed;<br>        }<br>    }<br><br>    public class Gallardo : Lanborghini {<br>        public int EnginePower = 1500;<br>        public int TireSize = 4;<br><br>        public Gallardo() {<br>           <br>        }<br>    }<br></p> |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

то его потомок унаследует это значение:\
![](../../\_pu/1/90920270.png)\
И при этом внутри себя может получать доступ к полю своего Дедушки.\
\
В следующий части мы поговорим о понятии "Полиморфизма" и.т.п.\


***

С этого урока вы уже понимаете, для чего нужен символ "**:**" в следующее выражение из уроков о ScriptHoockDotNet:

| <p>public class Thread : Script {<br>     // ...<br>}<br></p> |
| ------------------------------------------------------------- |

Класс Thread (наш аналог потока из Sanny Builder) наследует поля, свойства, методы, процедуры, классы и тому подобное из "главного" класса Script, который находится в библиотеке ScriptHookDotNet.dll.\
\
Это как минимум основы ООП, и у ваш арсенал сриптинга должны входить эти возможности и умение ими воспользоваться. :)\
\
Важно! В отличии от некоторых языков программирования, класс-Потомок может наследовать поля только одного класса-Родителя.\


***

P.S Возможно, некоторые вещи я неправильно назвал или описал. Напишите в комментах, что не так, я исправлю.|964|1|0|80243543`png`425`504`400`474\|49862482`png`174`173|26345781`png`174`156\|42299098`png`169`195|37370351`png`169`173\|46562547`png`187`148|07018888`png`167`195\|90920270`png`167`195||oop\_v\_c|1392798677
