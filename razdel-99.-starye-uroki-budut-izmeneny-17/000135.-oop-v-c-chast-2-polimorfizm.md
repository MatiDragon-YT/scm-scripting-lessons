# 000135. ООП в c# Часть 2 - Полиморфизм

ООП в c# Часть 2 - Полиморфизм||wmysterio|wmysterio|wmysterio@yandex.ru|||Это вторая часть по ООП в c#. Что же ещё спрятано под этим интересным словом? Очень многое! Сегодня я хотел-бы поговорить о таком интересном явлении, как "Полиморфизм". В переводе это слово означает "Изменять форму". В программировании это значит, что объекту одного класса можно присвоить значения другого объекта класса, оба из которых находятся в одной иерархии. Возьмём иерархию из предыдущего урока:

| <p>    public class Car {<br>        public int Speed = 0;<br><br>        public Car() { }<br><br>        private void SetSpeed(int NewSpeed) {<br>            Speed = NewSpeed;<br>        }<br>    }<br><br>    public class Lanborghini : Car{<br>        public int DoorCount = 4;<br>        public string EngineType = "Automatic";<br><br>        public Lanborghini() { }<br>    }<br><br>    public class Gallardo : Lanborghini {<br>        public int EnginePower = 1500;<br>        public int TireSize = 4;<br><br>        public Gallardo() { }<br>    }<br></p> |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

Теперь мы можем пользоваться следующими конструкторами:

| <p>Car MyCar0 = new Car();<br>Car MyCar1 = new Lanborghini();<br>Car MyCar2 = new Gallardo();<br>Lanborghini MyLambo = new Gallardo();<br>Gallardo MyGallardo = new Gallardo();<br></p> |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

А так же присваивать объектам одного класса значения объектов других:

| <p>MyCar0 = MyCar1;<br>MyCar0 = MyCar2;<br>MyCar0 = MyLambo;<br>MyCar0 = MyGallardo;<br>MyCar1 = MyCar0;<br>MyCar1 = MyCar2;<br>MyCar1 = MyLambo;<br>MyCar1 = MyGallardo;<br>MyCar2 = MyCar0;<br>MyCar2 = MyCar1;<br>MyCar2 = MyLambo;<br>MyCar2 = MyGallardo;<br>MyLambo = MyGallardo;<br></p> |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

Зелёным цветом я выделил процесс полиморфизма. При этом объект будет иметь только те команды, которые свойственны данному классу. То есть если в нас есть такой конструктор:

| <p>Car MyCar = new Lanborghini();<br></p> |
| ----------------------------------------- |

То MyCar будет иметь только те команды, которые есть в классе Car. Если в Lanborghini имелись такие поля:

| <p>public int DoorCount = 4;<br>public string EngineType = "Automatic";<br></p> |
| ------------------------------------------------------------------------------- |

То MyCar будет игнорировать их и выведет только эти:\
![](../\_pu/1/49802526.png)\
Однако что будет, если воспользоваться таким конструктором:

| <p>Gallardo MyGallardo = new Car();<br></p> |
| ------------------------------------------- |

?\
\
Нам выведет ошибку: "Ошибка 1 Не удается неявно преобразовать тип "Car" в "Gallardo". Существует явное преобразование". Давайте тогда преобразуем явно. Делается это, как уже звучало в ранних уроках, спомощью скобок перед выражением:

| <p>Gallardo MyGallardo = (Gallardo) new Car();<br><br>или так:<br><br>Gallardo MyGallardo = new Gallardo();<br>MyGallardo = (Gallardo)MyCar;<br></p> |
| ---------------------------------------------------------------------------------------------------------------------------------------------------- |

Отлично! Никаких ошибок в компиляторе в нас уже не возникает. Давайте запустим консольное приложение из этого кода

| <p>static void Main() {<br>    Car MyCar = new Lanborghini();<br>    Gallardo MyGallardo = (Gallardo)MyCar ;<br>    Console.ReadKey();<br>}<br></p> |
| --------------------------------------------------------------------------------------------------------------------------------------------------- |

что бы проверить на работоспособность программу и процесс преобразования. И опять у нас появилось исключение в таком страшном окне с сообщением: "Не удалось привести тип объекта "Consol.Lanborghini" к типу "Consol.Gallardo".". Напрашивается один вывод: "Нельзя преобразовать объекты в другие, если они являются выше по иерархии, то есть нельзя преобразовать Потомка в Родителя или старше". Также нельзя преобразовать объекты, которые наследуются от одного родителя. Например, если добавить новый класс Porche:

| <p>    public class Porshe : Car {<br>        public int DoorCount = 2;<br>        public string EngineType = "Automatic";<br>        public int WheelsSize = 5;<br><br>        public Porshe() { }<br>    }<br></p> |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

То преобразовать его в Lanborghini также не получится:

| <p>myLambo = (Lanborghini)myPorshe;<br>myPorshe = (Porshe)myLambo;<br></p> | <p>Сообщение компилятора: "Преобразование <strong>НЕВОЗМОЖНО</strong>", он даже не пытается преобразовать.<br></p> |
| -------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |

Вот такая небольшая порция информации о полиморфизме. Я не стал особо углубляться, для скриптинга GTA 4 этого вполне достаточно.|804|1|0|49802526`png`217\`157||oop\_v\_c\_chast\_2\_polimorfizm|1392798665
