# 000165. Цикл foreach для своих классов

Цикл foreach для своих классов||wmysterio|wmysterio|wmysterio@yandex.ru|/||

Всем привет! С вами, как обычно, wmysterio, и мы продолжаем изучать c#. В этом уроке мы постарается изучить одну интересную и не менее важную концепцию в c#. Как помочь классам подружиться с циклом foreach. Это обычно необходимо, когда класс имеет скрытое поле с массивом. При обращении к циклу, класс должен перебирать внутренний массив без необходимости получения его из вне.Чтобы узнать, что я имею ввиду, создадим несколько классов для примера. Первый класс будет иметь следующий вид:Кодpublic class ClassB {\
&#x20;  int \_value;\
&#x20;  public ClassB( int value ) { \_value = value; }\
&#x20;  public override string ToString() { return \_value.ToString(); }\
}Класс ничего не делает, но он будет являться важным содержимым для следующего класса:Кодpublic class ClassA : IEnumerable {\
&#x20;  ClassB\[] bList;\
&#x20;  public ClassA() {\
&#x20;     bList = new ClassB\[3] {\
&#x20;        new ClassB(10),\
&#x20;        new ClassB(-5),\
&#x20;        new ClassB(0)\
&#x20;     };\
&#x20; }\
&#x20;  public IEnumerator GetEnumerator() {\
&#x20;     for ( int i = 0; i < bList.Length; i++ )\
&#x20;         yield return bList\[ i ];\
&#x20;  }\
}Сразу в глаза попадаются два момента: реализация метода GetEnumerator()  из интерфейса IEnumerable и использование нового для Вас оператора yield. Об интерфейсах я расскажу Вам немного позже. Оператор yield используется для возвращения по очереди каждого элемента. То есть - отдавать кусками. Не ждать прохождения всего цикла, а отдавать элемент цикла в foreach, так только итерация цикла foreach завершилась, идёт получение следующего куска из цикла for, где находится наш yield. Чтобы понять как это работает, давайте в приложении создадим класс ClassA и пройдёмся в цикле foreach и увидим результат:Кодclass Program {\
&#x20;  static void Main( string\[] args ) {\
&#x20;     ClassA ca = new ClassA();\
&#x20;     foreach ( ClassB item in ca )\
&#x20;        Console.WriteLine( item );\
&#x20;     Console.ReadKey();\
&#x20;  }\
}Если Мы не знали что находится в классе ClassA, то нам и в голову не пришло бы, что с ним вообще возможный перебор через foreach. Обычно данный приём используется не для скрытия такой возможности, а для реализации этого класса в цикле foreach, и не только в нём.\
|912|1|0|42460690`png`108\`113||cikl\_foreach\_dlja\_svoikh\_klassov|1423936483
